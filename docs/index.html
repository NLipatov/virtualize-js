<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Virtualize Demo</title>
    <link rel="stylesheet" href="./styles.css">
</head>

<body>

<footer>
    <div class="controls">
        <label for="itemCount">
            <span>Items count:</span>
            <input type="number" id="itemCount" placeholder="Count" min="5" value="100">
        </label>
        <label for="bufferMultiplier">
            <span>Buffer multiplier:</span>
            <input type="number" id="bufferMultiplier" placeholder="Buffer Multiplier" min="0" value="2">
        </label>
        <button id="renderButton">Render</button>
    </div>
</footer>

<main id="items-container">
    <!-- items will be rendered here -->
</main>

</body>

</html>

<style>
    body {
        margin: 0;
        font-size: 1rem;
    }

    .controls {
        display: flex;
        flex-direction: column;
    }

    button {
        width: 7rem;
    }
</style>

<script>
    'use strict';
    const itemsContainer = document.getElementById('items-container');
    const renderButton = document.getElementById('renderButton');
    const itemCountInput = document.getElementById('itemCount');

    const colors = ['#f0f0f0', '#d0e8ff', '#d0ffd0', '#fffacd', '#ffd0d0'];

    let items = [];

    let bufferMultiplier = 2;
    setBufferMultiplier(2);

    function generateItems(count) {
        items = [];

        for (let i = 0; i < count; i++) {
            const height = getRandomHeight(50, 300);
            const colorIndex = i % colors.length;
            items.push({
                index: i,
                text: `Item #${i + 1}`,
                height,
                color: colors[colorIndex],
            });
        }

        render(items, itemsContainer);
    }

    const getRandomHeight = (min, max) => {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    renderButton.addEventListener('click', function () {
        const count = parseInt(itemCountInput.value, 10);

        if (count > 0) {
            generateItems(count);
            itemsContainer.style.height = `${window.innerHeight - document.querySelector('footer').offsetHeight}px`;
            itemsContainer.style.overflowY = 'scroll';
            render(items, itemsContainer);
        } else {
            alert('Invalid item count!');
        }
    });


    itemsContainer.addEventListener('scroll', () => {
        render(items, itemsContainer);
    });

    window.addEventListener('resize', () => {
        itemsContainer.style.height = `${window.innerHeight - document.querySelector('footer').offsetHeight}px`;
        render(items, itemsContainer);
    });

    /**
     * Sets the buffer multiplier that controls the number of additional elements rendered
     * above and below the viewport.
     *
     * For example:
     * - If the viewport can display 10 items and the bufferMultiplier is set to 2,
     *   then 20 additional items will be rendered above and 20 below the viewport.
     * - This means a total of 50 items will be rendered: 10 visible items, 20 in the top buffer,
     *   and 20 in the bottom buffer.
     *
     * @param {number} multiplier - The multiplier used to determine the number of buffer items to render.
     */
    function setBufferMultiplier(multiplier) {
        bufferMultiplier = multiplier;
    }

    function render(items, itemsContainer) {
        const containerHeight = itemsContainer.clientHeight;
        const scrollTop = itemsContainer.scrollTop;

        const {startIndex, endIndex} = calculateVisibleElements(items, scrollTop, containerHeight);

        const bufferItemsCount = Math.ceil((endIndex - startIndex) * bufferMultiplier);

        const renderStartIndex = Math.max(0, startIndex - bufferItemsCount);
        const renderEndIndex = Math.min(items.length, endIndex + bufferItemsCount);

        itemsContainer.innerHTML = '';

        const topSpacer = document.createElement('div');
        const topSpacerHeight = items.slice(0, renderStartIndex).reduce((acc, item) => acc + item.height, 0);
        topSpacer.style.height = `${topSpacerHeight}px`;
        itemsContainer.appendChild(topSpacer);

        for (let i = renderStartIndex; i < renderEndIndex; i++) {
            const message = document.createElement('div');
            message.textContent = `${items[i].text}`;
            message.style.height = `${items[i].height}px`;
            message.style.backgroundColor = items[i].color;
            itemsContainer.appendChild(message);
        }

        const bottomSpacer = document.createElement('div');
        const bottomSpacerHeight = items.slice(renderEndIndex).reduce((acc, item) => acc + item.height, 0);
        bottomSpacer.style.height = `${bottomSpacerHeight}px`;
        itemsContainer.appendChild(bottomSpacer);
    }

    /**
     * Calculates the indices of the items that should be visible within the viewport.
     *
     * This function determines the start and end indices of the items that need to be rendered
     * based on the current scroll position (`scrollTop`) and the height of the container (`containerHeight`).
     *
     * The function works as follows:
     * - First, it calculates the `startIndex`, which is the index of the first item that should be visible
     *   in the viewport, by summing up the heights of the items until the cumulative height exceeds the scroll position.
     * - Next, it calculates the `endIndex`, which is the index of the last item that should be visible
     *   in the viewport, by summing up the heights of the items starting from the `startIndex`
     *   until the cumulative height exceeds the container's height.
     * - If the height of the item at `startIndex` is greater than the container's height and no other items
     *   would fit, the function ensures that at least one item is rendered by incrementing the `endIndex`.
     *
     * @param {Array} items - An array of item objects, where each item has a `height` property.
     * @param {number} scrollTop - The current vertical scroll position of the container.
     * @param {number} containerHeight - The height of the container (viewport) in pixels.
     *
     * @returns {Object} - An object containing `startIndex` and `endIndex`, representing the range of items
     *                     that should be rendered based on the visible viewport.
     */
    function calculateVisibleElements(items, scrollTop, containerHeight) {
        let startIndex = 0;
        let accumulatedHeight = 0;

        for (let i = 0; i < items.length; i++) {
            accumulatedHeight += items[i].height;
            if (accumulatedHeight > scrollTop) {
                startIndex = i;
                break;
            }
        }

        let endIndex = startIndex;
        accumulatedHeight = 0;
        for (let i = startIndex; i < items.length; i++) {
            accumulatedHeight += items[i].height;
            if (accumulatedHeight >= containerHeight) {
                endIndex = i;
                break;
            }
        }

        // Ensure at least one element is rendered, even if it is taller than the container
        if (endIndex === startIndex && items[startIndex].height > containerHeight) {
            endIndex = startIndex + 1;
        }

        return {startIndex, endIndex};
    }
</script>